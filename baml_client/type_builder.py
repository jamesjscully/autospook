###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["EvidenceSnippet","ExaResult","ExaSearchResults","HtmlReport","Question","QuestionStatus","Stepback","TopicStatus",]
        ), enums=set(
          ["Criticality","QuestionLabel","TopicCompletion",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def EvidenceSnippet(self) -> "EvidenceSnippetAst":
        return EvidenceSnippetAst(self)

    @property
    def ExaResult(self) -> "ExaResultAst":
        return ExaResultAst(self)

    @property
    def ExaSearchResults(self) -> "ExaSearchResultsAst":
        return ExaSearchResultsAst(self)

    @property
    def HtmlReport(self) -> "HtmlReportAst":
        return HtmlReportAst(self)

    @property
    def Question(self) -> "QuestionAst":
        return QuestionAst(self)

    @property
    def QuestionStatus(self) -> "QuestionStatusAst":
        return QuestionStatusAst(self)

    @property
    def Stepback(self) -> "StepbackAst":
        return StepbackAst(self)

    @property
    def TopicStatus(self) -> "TopicStatusAst":
        return TopicStatusAst(self)





class EvidenceSnippetAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvidenceSnippet")
        self._properties: typing.Set[str] = set([ "title",  "url",  "snippet",  "published_date", ])
        self._props = EvidenceSnippetProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvidenceSnippetProperties":
        return self._props


class EvidenceSnippetViewer(EvidenceSnippetAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvidenceSnippetProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("url"))

    @property
    def snippet(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("snippet"))

    @property
    def published_date(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("published_date"))

    

class ExaResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExaResult")
        self._properties: typing.Set[str] = set([ "id",  "title",  "url",  "score",  "published_date",  "text", ])
        self._props = ExaResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExaResultProperties":
        return self._props


class ExaResultViewer(ExaResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExaResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("url"))

    @property
    def score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("score"))

    @property
    def published_date(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("published_date"))

    @property
    def text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("text"))

    

class ExaSearchResultsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExaSearchResults")
        self._properties: typing.Set[str] = set([ "query",  "num_results",  "results", ])
        self._props = ExaSearchResultsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExaSearchResultsProperties":
        return self._props


class ExaSearchResultsViewer(ExaSearchResultsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExaSearchResultsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("query"))

    @property
    def num_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num_results"))

    @property
    def results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("results"))

    

class HtmlReportAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("HtmlReport")
        self._properties: typing.Set[str] = set([ "html", ])
        self._props = HtmlReportProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HtmlReportProperties":
        return self._props


class HtmlReportViewer(HtmlReportAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class HtmlReportProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def html(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("html"))

    

class QuestionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Question")
        self._properties: typing.Set[str] = set([ "text",  "criticality", ])
        self._props = QuestionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestionProperties":
        return self._props


class QuestionViewer(QuestionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("text"))

    @property
    def criticality(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("criticality"))

    

class QuestionStatusAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("QuestionStatus")
        self._properties: typing.Set[str] = set([ "question",  "label",  "rationale",  "evidence", ])
        self._props = QuestionStatusProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestionStatusProperties":
        return self._props


class QuestionStatusViewer(QuestionStatusAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestionStatusProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("question"))

    @property
    def label(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("label"))

    @property
    def rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rationale"))

    @property
    def evidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("evidence"))

    

class StepbackAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Stepback")
        self._properties: typing.Set[str] = set([ "expanded_context", ])
        self._props = StepbackProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StepbackProperties":
        return self._props


class StepbackViewer(StepbackAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StepbackProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def expanded_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expanded_context"))

    

class TopicStatusAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TopicStatus")
        self._properties: typing.Set[str] = set([ "topic",  "completion",  "rationale", ])
        self._props = TopicStatusProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TopicStatusProperties":
        return self._props


class TopicStatusViewer(TopicStatusAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TopicStatusProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def topic(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("topic"))

    @property
    def completion(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("completion"))

    @property
    def rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rationale"))

    



class CriticalityAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Criticality")
        self._values: typing.Set[str] = set([ "SECURITY_CRITICAL",  "CONTEXTUAL", ])
        self._vals = CriticalityValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CriticalityValues":
        return self._vals


class CriticalityViewer(CriticalityAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class CriticalityValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def SECURITY_CRITICAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("SECURITY_CRITICAL"))
    

    @property
    def CONTEXTUAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CONTEXTUAL"))
    

    

class QuestionLabelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("QuestionLabel")
        self._values: typing.Set[str] = set([ "OPEN",  "CLOSED",  "UNANSWERABLE", ])
        self._vals = QuestionLabelValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "QuestionLabelValues":
        return self._vals


class QuestionLabelViewer(QuestionLabelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class QuestionLabelValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def OPEN(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("OPEN"))
    

    @property
    def CLOSED(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CLOSED"))
    

    @property
    def UNANSWERABLE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("UNANSWERABLE"))
    

    

class TopicCompletionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TopicCompletion")
        self._values: typing.Set[str] = set([ "OPEN",  "SATISFIED",  "UNSATISFIABLE", ])
        self._vals = TopicCompletionValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TopicCompletionValues":
        return self._vals


class TopicCompletionViewer(TopicCompletionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class TopicCompletionValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def OPEN(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("OPEN"))
    

    @property
    def SATISFIED(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("SATISFIED"))
    

    @property
    def UNSATISFIABLE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("UNSATISFIABLE"))
    

    


__all__ = ["TypeBuilder"]